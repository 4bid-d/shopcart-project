"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testing = void 0;
exports.testing = (name) => `Hello ${name}`;
const Promise = require("bluebird");
const mongodb_1 = require("mongodb");
const mongoDB = () => {
    const GridStore = require('mongodb').GridStore;
    const ISODate = require('mongodb').ISODate;
    const Chunk = require('mongodb').Chunk;
    const CoreServer = require('mongodb').CoreServer;
    const CoreConnection = require('mongodb').CoreConnection;
    const BSONRegExp = require('mongodb').BSONRegExp;
    const instrument = require('mongodb').instrument;
    const Symbol = require('mongodb').Symbol;
    const Map = require('mongodb').Map;
    const mongoDbHelper = {};
    // expose native elements
    mongoDbHelper.MongoClient = mongodb_1.MongoClient;
    mongoDbHelper.MongoError = mongodb_1.MongoError;
    mongoDbHelper.MongoNetworkError = mongodb_1.MongoNetworkError;
    mongoDbHelper.Db = mongodb_1.Db;
    mongoDbHelper.Server = mongodb_1.Server;
    mongoDbHelper.ReplSet = mongodb_1.ReplSet;
    mongoDbHelper.Mongos = mongodb_1.Mongos;
    mongoDbHelper.ReadPreference = mongodb_1.ReadPreference;
    mongoDbHelper.GridStore = GridStore;
    mongoDbHelper.Chunk = Chunk;
    mongoDbHelper.Logger = mongodb_1.Logger;
    mongoDbHelper.AggregationCursor = mongodb_1.AggregationCursor;
    mongoDbHelper.CommandCursor = mongodb_1.CommandCursor;
    mongoDbHelper.Cursor = mongodb_1.Cursor;
    mongoDbHelper.GridFSBucket = mongodb_1.GridFSBucket;
    mongoDbHelper.CoreServer = CoreServer;
    mongoDbHelper.CoreConnection = CoreConnection;
    mongoDbHelper.Binary = mongodb_1.Binary;
    mongoDbHelper.Code = mongodb_1.Code;
    mongoDbHelper.Map = Map;
    mongoDbHelper.DBRef = mongodb_1.DBRef;
    mongoDbHelper.Double = mongodb_1.Double;
    mongoDbHelper.Int32 = mongodb_1.Int32;
    mongoDbHelper.Long = mongodb_1.Long;
    mongoDbHelper.MinKey = mongodb_1.MinKey;
    mongoDbHelper.MaxKey = mongodb_1.MaxKey;
    mongoDbHelper.ObjectID = mongodb_1.ObjectID;
    mongoDbHelper.ObjectId = mongodb_1.ObjectId;
    mongoDbHelper.Symbol = Symbol;
    mongoDbHelper.Timestamp = mongodb_1.Timestamp;
    mongoDbHelper.BSONRegExp = BSONRegExp;
    mongoDbHelper.Decimal128 = mongodb_1.Decimal128;
    mongoDbHelper.ISODate = ISODate;
    mongoDbHelper.instrument = instrument;
    const BSON = require('bson');
    // mongoDbHelper.mDB; --> exposed connected client
    let initEventListener = false;
    let reconnectedPending = false;
    mongoDbHelper.forceReconnect = (conf) => {
        return new Promise((Ok /*, Ko*/) => {
            if (!reconnectedPending) {
                if (conf.forceReconnect && conf.forceReconnectLimit > 0) {
                    reconnectedPending = true;
                    conf.forceReconnectLimit -= 1;
                    console.error('serverClosed or topologyClosed, try forceReconnect', conf.forceReconnectLimit);
                    mongoDbHelper.connect(conf).finally(() => {
                        reconnectedPending = false;
                        Ok();
                    });
                }
                else {
                    Ok();
                }
            }
            else {
                Ok();
            }
        });
    };
    const disconnectHandler = (msg) => {
        delete mongoDbHelper.mDB;
        mongoDbHelper.forceReconnect(mongoDbHelper.config);
    };
    const waitConnect = () => {
        return new Promise((resolve) => {
            if (mongoDbHelper.mDB === undefined) {
                setTimeout(() => {
                    waitConnect()
                        .then(() => {
                        resolve();
                    })
                        .catch(() => {
                        resolve();
                    });
                }, 1500);
            }
            else {
                resolve();
            }
        });
    };
    mongoDbHelper.initEventListener = () => {
        initEventListener = true;
        mongoDbHelper.mDB.on('serverClosed', disconnectHandler);
        mongoDbHelper.mDB.on('topologyClosed', disconnectHandler);
    };
    mongoDbHelper.destroyEventListener = () => {
        initEventListener = false;
        mongoDbHelper.mDB.removeListener('serverClosed', disconnectHandler);
        mongoDbHelper.mDB.removeListener('topologyClosed', disconnectHandler);
    };
    mongoDbHelper.connect = (conf) => {
        return new Promise((resolve, reject) => {
            mongoDbHelper.config = Object.assign({}, conf);
            const config = Object.assign({}, conf);
            let uri = '';
            let opts = {};
            if (config !== undefined &&
                config !== null &&
                config !== false &&
                config.user !== undefined &&
                config.password !== undefined &&
                config.host !== undefined &&
                config.port !== undefined) {
                if (config.dbName === undefined) {
                    config.dbName = 'admin';
                }
                const dbName = config.dbName;
                const host = config.host;
                const port = config.port;
                const user = config.user;
                const password = config.password;
                mongoDbHelper.usedDB = config.dbName;
                uri = `mongodb://${host}:${port}/${dbName}`;
                opts = {
                    authSource: dbName,
                    keepAlive: true,
                    poolSize: 20,
                    sslValidate: false,
                    useNewUrlParser: true,
                    useUnifiedTopology: true,
                };
                if (config.user !== undefined) {
                    opts.auth = {
                        password,
                        user,
                    };
                }
                // use unified topology url syntax for replicaset
                if (config.replicaSet) {
                    uri += '?replicaSet=' + config.replicaSet;
                }
                for (const optKey in config) {
                    if (!['forceReconnectLimit', 'forceReconnect', 'password', 'user', 'dbName', 'port', 'host'].includes(optKey)) {
                        opts[optKey] = config[optKey];
                    }
                }
                mongoDbHelper.mDB = new mongoDbHelper.MongoClient(uri, opts);
                mongoDbHelper.mDB
                    .connect()
                    .then(( /*dbclient*/) => {
                    if (!initEventListener) {
                        mongoDbHelper.initEventListener();
                    }
                    resolve(mongoDbHelper.mDB);
                })
                    .catch((err) => {
                    delete mongoDbHelper.mDB;
                    reject(err);
                });
            }
            else {
                if (config !== undefined) {
                    delete mongoDbHelper.mDB;
                    reject({
                        diagnose: { config, uri, opts },
                        error: 'invalid MongoDB configuration!',
                    });
                }
                else {
                    delete mongoDbHelper.mDB;
                    resolve();
                }
            }
        });
    };
    mongoDbHelper.close = () => {
        return new Promise((Ok /*, Ko*/) => {
            if (mongoDbHelper.mDB !== undefined) {
                if (initEventListener) {
                    mongoDbHelper.destroyEventListener();
                }
                mongoDbHelper.mDB
                    .close()
                    .then(() => {
                    Ok();
                })
                    .catch((err) => {
                    Ok(err);
                });
            }
            else {
                Ok();
            }
        });
    };
    mongoDbHelper.count = (collection, filter) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                const filterFind = filter !== undefined ? filter : {};
                mongoDbHelper.mDB
                    .db(mongoDbHelper.usedDB)
                    .collection(collection)
                    .countDocuments(filterFind)
                    .then((result) => {
                    Ok(result);
                })
                    .catch((err) => {
                    Ko(err);
                });
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.purgeBefore = (collection, filterKey, olderThanSecond) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                const date = new Date();
                const filter = {};
                filter[filterKey] = { $lt: new Date(date - 1000 * olderThanSecond) };
                mongoDbHelper.mDB
                    .db(mongoDbHelper.usedDB)
                    .collection(collection)
                    .deleteMany(filter)
                    .then((result) => {
                    Ok(result);
                })
                    .catch((err) => {
                    Ko(err);
                });
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.delete = (collection, filter) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                const filterDelete = filter !== undefined ? filter : {};
                if (filterDelete instanceof Array) {
                    Promise.map(filterDelete, (filterDeleteSingle) => {
                        return mongoDbHelper.delete(collection, filterDeleteSingle);
                    })
                        .then((result) => {
                        Ok(result);
                    })
                        .catch((err) => {
                        Ko(err);
                    });
                }
                else {
                    mongoDbHelper.mDB
                        .db(mongoDbHelper.usedDB)
                        .collection(collection)
                        .deleteMany(filterDelete)
                        .then((result) => {
                        Ok(result);
                    })
                        .catch((err) => {
                        Ko(err);
                    });
                }
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.eval = (rawScript, inputs) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                let inputsStr = '';
                if (typeof inputs === 'object') {
                    inputsStr = JSON.stringify(inputs);
                }
                const executed = 'let inputs = ' + inputsStr + ';let db = mongoDbHelper.mDB;' + rawScript;
                eval(executed)
                    .then((result) => {
                    Ok(result);
                })
                    .catch((err) => {
                    Ko(err);
                });
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.aggregate = (collection, AggResquests) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                return mongoDbHelper.mDB.db(mongoDbHelper.usedDB).collection(collection).aggregate(AggResquests).toArray();
            })
                .then((result) => {
                Ok(result);
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.find = (collection, filter, projection, sort, limit) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                const limitFind = limit !== undefined ? limit : 100;
                const filterFind = filter !== undefined ? filter : {};
                const projectionFind = projection !== undefined ? projection : {};
                const sortFind = sort !== undefined ? sort : {};
                if (Array.isArray(filterFind)) {
                    Promise.map(filterFind, (filterFindSingle) => {
                        return mongoDbHelper.find(collection, filterFindSingle, projectionFind, sortFind);
                    })
                        .then((result) => {
                        Ok(result);
                    })
                        .catch((err) => {
                        Ko(err);
                    });
                }
                else {
                    mongoDbHelper.mDB
                        .db(mongoDbHelper.usedDB)
                        .collection(collection)
                        .find(filterFind, { projection: projectionFind })
                        .sort(sortFind)
                        .limit(limitFind)
                        .toArray()
                        .then((result) => {
                        Ok(result);
                    })
                        .catch((err) => {
                        Ko(err);
                    });
                }
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.insert = (collection, documents) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                if (documents === undefined) {
                    Ok();
                }
                else {
                    if (!(documents instanceof Array)) {
                        documents = [documents];
                    }
                    mongoDbHelper.mDB
                        .db(mongoDbHelper.usedDB)
                        .collection(collection)
                        .insertMany(documents)
                        .then((result) => {
                        Ok(result);
                    })
                        .catch((err) => {
                        Ko(err);
                    });
                }
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.replace = (collection, filter, to) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                if (filter === undefined || filter === {}) {
                    Ok();
                }
                else {
                    if (filter instanceof Array) {
                        Promise.map(filter, (filterReplaceSingle) => {
                            return mongoDbHelper.replace(collection, filterReplaceSingle, to);
                        })
                            .then((result) => {
                            Ok(result);
                        })
                            .catch((err) => {
                            Ko(err);
                        });
                    }
                    else {
                        mongoDbHelper.mDB
                            .db(mongoDbHelper.usedDB)
                            .collection(collection)
                            .replaceOne(filter, to)
                            .then((result) => {
                            Ok(result);
                        })
                            .catch((err) => {
                            Ko(err);
                        });
                    }
                }
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.update = (collection, filter, values, upsert) => {
        return new Promise((Ok, Ko) => {
            waitConnect()
                .then(() => {
                const filterUpdate = filter !== undefined ? filter : {};
                const valuesUpdate = values !== undefined ? values : {};
                const upsertUpdate = upsert !== undefined ? upsert : false;
                if (filterUpdate instanceof Array) {
                    Promise.map(filterUpdate, (filterUpdateSingle) => {
                        return mongoDbHelper.update(collection, filterUpdateSingle, valuesUpdate, upsertUpdate);
                    })
                        .then((result) => {
                        Ok(result);
                    })
                        .catch((err) => {
                        Ko(err);
                    });
                }
                else {
                    mongoDbHelper.mDB
                        .db(mongoDbHelper.usedDB)
                        .collection(collection)
                        .updateMany(filterUpdate, valuesUpdate, { upsert: upsertUpdate })
                        .then((result) => {
                        Ok(result);
                    })
                        .catch((err) => {
                        Ko(err);
                    });
                }
            })
                .catch((e) => {
                Ko(e);
            });
        });
    };
    mongoDbHelper.collections = (database) => {
        const dbUsed = database !== undefined && database !== mongoDbHelper.usedDB ? database : mongoDbHelper.usedDB;
        return new Promise((Ok, Ko) => {
            mongoDbHelper.mDB
                .db(dbUsed)
                .collections()
                .then((result) => {
                Ok(result);
            })
                .catch((err) => {
                Ko(err);
            });
        });
    };
    mongoDbHelper.export = (collections, data) => {
        const promises = [];
        collections.forEach((val /*, index*/) => {
            promises.push(new Promise((resolve, error) => {
                mongoDbHelper.count(val).then((countObject) => {
                    mongoDbHelper
                        .find(val, null, {}, { _id: 1 }, countObject)
                        .then((result) => {
                        // Manage received data
                        data[val] = mongoDbHelper.serialize(result);
                        resolve();
                    })
                        .catch((err) => {
                        error(err);
                    });
                });
            }));
        });
        return Promise.all(promises).then(() => {
            return data;
        });
    };
    mongoDbHelper.import = (data) => {
        const promises = [];
        const result = {};
        Object.keys(data).forEach((collection) => {
            promises.push(new Promise((resolve, error) => {
                const documents = BSON.deserialize(data[collection]);
                mongoDbHelper.mDB
                    .db(mongoDbHelper.usedDB)
                    .collection(collection)
                    .insertMany(documents)
                    .then((res) => {
                    // Manage operation result
                    result[collection] = res;
                    resolve();
                })
                    .catch((err) => {
                    error(err);
                });
            }));
        });
        return Promise.all(promises).then(() => {
            return result;
        });
    };
    mongoDbHelper.createIndexes = (collection, indexes) => {
        return new Promise((created, error) => {
            mongoDbHelper.mDB
                .db(mongoDbHelper.usedDB)
                .collection(collection)
                .createIndexes(indexes)
                .then((result) => {
                created(result);
            })
                .catch((err) => {
                error(err);
            });
        });
    };
    mongoDbHelper.indexes = (collection) => {
        return new Promise((indexes, error) => {
            mongoDbHelper.mDB
                .db(mongoDbHelper.usedDB)
                .collection(collection)
                .indexes((err, result) => {
                if (err) {
                    error(err);
                }
                indexes(result);
            });
        });
    };
    mongoDbHelper.deserialize = (input) => {
        const objects = [];
        let startIndex = 0;
        const length = input.length;
        let remaining = input;
        while (startIndex < length - 1) {
            const object = BSON.deserialize(remaining, { allowObjectSmallerThanBufferSize: true });
            startIndex += BSON.calculateObjectSize(object);
            remaining = input.slice(startIndex);
            objects.push(object);
        }
        return objects.length > 1 ? objects : objects[0];
    };
    mongoDbHelper.serialize = (input) => {
        const buffers = [];
        if (Array.isArray(input)) {
            input.forEach((val) => {
                buffers.push(BSON.serialize(val));
            });
        }
        else {
            buffers.push(BSON.serialize(input));
        }
        return Buffer.concat(buffers);
    };
    return mongoDbHelper;
};
exports.default = mongoDB;
